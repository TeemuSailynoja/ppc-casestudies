{
  "hash": "48af24d66b99fa3681f4c57d79a3dc68",
  "result": {
    "markdown": "---\ntitle: \"Calibrarion of Ordinal Posterior Predictions\"\nauthor: \"Teemu SÃ¤ilynoja\"\ndate: \"2023-02-04\"\ndate-modified: \"2023-02-13\"\nimage: \"../../docs/case_studies/ordinal/ordinal_files/figure-html/reliability-diagrams_1-1.svg\"\nformat:\n  html:\n    toc: true\n    code-fold: true\n    code-tools: true\n    code-line-numbers: true\n    default-image-extension: svg\n    fig-format: svg\n# knitr:\n#   opts_chunk:\n#     classes : \"dark-light\"\n\n---\n\n::: {.cell}\n\n\n```{.r .cell-code  code-summary=\"Imports & options\"}\nlibrary(\"bayesplot\")\nlibrary(\"cmdstanr\")\nlibrary(\"ggplot2\")\nlibrary(\"khroma\")\nlibrary(\"quartoExtra\")\n\n\n# Source for the modified reliability plot\nsource(\"../../code/helpers.R\")\n\ngood_theme <- bayesplot::theme_default(base_family = \"Sans\") + theme(\n  axis.text = element_text(colour = \"#666666\", size = 12),\n  axis.ticks = element_line(colour = \"#666666\"),\n  title = element_text(colour = \"#666666\", size = 16),\n  plot.subtitle = element_text(colour = \"#666666\", size = 14),\n  legend.text = element_text(colour = \"#666666\", size = 12),\n  legend.title = element_text(colour = \"#666666\", size = 14),\n  axis.line = element_line(colour = \"#666666\"))\n\ntheme_set(good_theme)\nbayesplot_theme_set(good_theme)\ncolor_scheme_set(scheme = c(unname(colour(\"vibrant\")(7)[c(3,2,5,4,1,6)])))\n\nscale_colour_discrete = scale_colour_vibrant\nscale_fill_discrete = scale_fill_vibrant\n\n\n# darkmode_theme_set(\n#     dark = ggthemes::theme_stata(scheme = \"s1rcolor\"),\n#     light = ggthemes::theme_stata(scheme = \"s1color\")\n# )\n\n\nSEED <- 236543\nset.seed(SEED)\nSAVE_FITS = TRUE\n```\n\n\n:::\n\n\nThis notebook highlights posterior predictive visualizations when the \nposterior predictive distribution is ordinal.\n\nAs shown below, the ordinal nature of the predictions allows us to use the\ncumulative posterior predictive mass function to assess the calibration of the \nposterior.\n\n## Data set\nBelow, I use synthetic data generated from observations from $K$ Gaussians with\nvarying means.\n\n$$\\begin{align}\nx_n &\\sim \\mathcal N\\!\\!\\left(k, 0.5^2\\right), &\\text{for } n \\in\\{1,\\dots,N\\}\\\\\nk &\\sim \\text{Categorical}(\\theta_k),&\\\\\n\\theta_k &= \\frac 1 K, &\\text{for } k \\in \\{1, \\dots, K\\}.\n\\end{align}$$\n\n\n::: {.cell}\n\n\n```{.r .cell-code  code-summary=\"Data generation\"}\nK <- 5\nN <- 1500\nsigma <- .5\nc <- sample(1:K, N, replace = T)\nx <- rnorm(N, c, sigma)\nstandata_gmm <- list(K = K,\n                     N = N,\n                     x = x,\n                     y = c,\n                     sigma = sigma)\n```\n\n\n:::\n\n::: {.cell}\n\n\n```{.r .cell-code}\nggplot(data.frame(standata_gmm)) +\n  geom_density(aes(x = x,\n                   colour = as.factor(y),\n                   fill = as.factor(y),\n                   group = as.factor(y)), alpha = .5) +\n  legend_none() +\n  xlab(\"\") + ylab(\"\") + ggtitle(paste(\"The data\", sep = \"\"))\n```\n\n::: {.cell-output-display}\n![](ordinal_files/figure-html/data_densities-1.svg)\n:::\n\n\n:::\n\n\n## Model\n\nThe data is fit with two models, both structured to first normalize the data and\nthen fit a GMM with K = 5` \n\n::: {.cell}\n\n\n```{.r .cell-code  code-summary=\"Read model code\"}\ngmm <- cmdstan_model(\"../../code/stan-models/gmm_classifier.stan\")\ngmm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndata {\n  int<lower=2> K;                   // Number of classes\n  int<lower=0> N;                   // Total number of observations\n  array[N] int<lower=1, upper=K> y; // Target classes\n  vector[N] x;                      // Observed predictor values\n  real<lower=0> sigma;              // User supplied standard deviation\n  int correct_sigma;                // How to handle sigma, see below.\n}\n\ntransformed data{\n  vector[N] x_st;\n  real Sigma;\n\n  // Standardize data\n  x_st = (x - mean(x)) / sd(x);\n\n  // Maybe remember to scale sigma accordingly\n  if (correct_sigma == 1) {\n    Sigma = sigma / sd(x);\n  } else {\n    Sigma = sigma;\n  }\n}\n\nparameters {\n  // Inferred means.\n  ordered[K] c;\n  simplex[K] p_c;\n}\n\nmodel {\n  // Prior\n  c ~ normal(0,1);\n  p_c ~ dirichlet(rep_vector(1,K));\n\n  // Likelihood\n  for (n in 1:N) {\n    target += normal_lpdf(x_st[n] | c[y[n]], Sigma);\n  }\n}\n\ngenerated quantities {\n  // Posterior predictive sample\n  vector[N] yrep;\n  // For each observation, posterior predictive mass of classes\n  array[N] vector[K] ppm;\n\n  for (n in 1:N) {\n    for (k in 1:K) {\n      ppm[n, k] = normal_lpdf(x_st[n] | c[k], Sigma);\n    }\n    ppm[n, ] = softmax(ppm[n, ]);\n    yrep[n] = categorical_rng(ppm[n, ]);\n  }\n}\n```\n:::\n\n\n:::\n\n::: {.cell}\n\n\n```{.r .cell-code  code-summary=\"run CmdStanR\"}\nfit_1 <- tryCatch(\n  expr = {readRDS(paste(\"../../code/stan-models/fits/gmm_classifier_1_\",SEED,\".RDS\", sep=\"\"))},\n  error = function(e) {\n    fit <- gmm$sample(data = c(standata_gmm, list(correct_sigma = 0)),\n                      parallel_chains = 4,\n                      refresh = 0,\n                      seed = SEED,\n                      show_messages = F)\n    if (SAVE_FITS) {fit$save_object(\n      paste(\"../../code/stan-models/fits/gmm_classifier_1_\",SEED,\".RDS\", sep=\"\"))}\n    return(fit)},\n  finally = {message(\"Finished model 1.\")})\n\nfit_2 <- tryCatch(\n  expr = readRDS(paste(\"../../code/stan-models/fits/gmm_classifier_2_\",SEED,\".RDS\", sep=\"\")),\n  error = function(e) {\n    fit <- gmm$sample(data = c(standata_gmm, list(correct_sigma = 1)),\n               parallel_chains = 4,\n               refresh = 0,\n               seed = SEED,\n               show_messages = F)\n    if (SAVE_FITS) {fit$save_object(\n      paste(\"../../code/stan-models/fits/gmm_classifier_2_\",SEED,\".RDS\", sep=\"\"))}\n    return(fit)},\n  finally = {message(\"Finished model 2.\")})\n```\n\n\n:::\n\n::: {.cell}\n\n\n```{.r .cell-code}\np_1 <- matrix(colMeans(fit_1$draws(variables = \"ppm\", format = \"matrix\")), ncol = K)\np_2 <- matrix(colMeans(fit_2$draws(variables = \"ppm\", format = \"matrix\")), ncol = K)\n```\n\n\n:::\n\n\n## PPC\n\n:::{layout-ncol=\"2\"}\n\n\n::: {.cell}\n\n\n```{.r .cell-code}\nppc_bars(y = as.numeric(c),\n         yrep = fit_1$draws(variables = \"yrep\",format = \"matrix\")) +\n  ggtitle(\"Model 1\") +\n  theme(legend.position = \"bottom\")\n```\n\n::: {.cell-output-display}\n![](ordinal_files/figure-html/ppc_bars_1-1.svg){fig-align='right'}\n:::\n\n\n:::\n\n::: {.cell}\n\n\n```{.r .cell-code}\nppc_bars(y = as.numeric(c),\n         yrep = fit_2$draws(variables = \"yrep\", format = \"matrix\")) +\n  ggtitle(\"Model 2\") +\n  theme(legend.position = \"bottom\") \n```\n\n::: {.cell-output-display}\n![](ordinal_files/figure-html/ppc_bars_2-1.svg){fig-align='left'}\n:::\n\n\n:::\n\n:::\n\n\n:::{layout-ncol=\"2\"}\n\n::: {.cell}\n\n\n```{.r .cell-code}\nfor (k in 1:(K - 1)) {\n  p1 <- plot_dotted_reliabilitydiag(\n    y = as.numeric(c <= k),\n    x = if (k != 1) pmin(1, rowSums(p_1[, 1:k])) else p_1[, k],\n    quantiles = K * N / 100,\n    dot_scale = .5) +\n    ggtitle(paste(\"Model 1: P(y <= \", k, \")\", sep=\"\"),\n            subtitle = \"1 dot = 100 observations\")\n  \n  print(p1)\n}\n```\n\n::: {.cell-output-display}\n![](ordinal_files/figure-html/reliability-diagrams_1-1.svg){fig-align='right'}\n:::\n\n::: {.cell-output-display}\n![](ordinal_files/figure-html/reliability-diagrams_1-2.svg){fig-align='right'}\n:::\n\n::: {.cell-output-display}\n![](ordinal_files/figure-html/reliability-diagrams_1-3.svg){fig-align='right'}\n:::\n\n::: {.cell-output-display}\n![](ordinal_files/figure-html/reliability-diagrams_1-4.svg){fig-align='right'}\n:::\n\n\n:::\n\n::: {.cell}\n\n\n```{.r .cell-code}\nfor (k in 1:(K - 1)) {\n  p2 <- plot_dotted_reliabilitydiag(\n    y = as.numeric(c <= k),\n    x = if (k != 1) pmin(1, rowSums(p_2[, 1:k])) else p_2[, k],\n    quantiles = K * N / 100,\n    dot_scale = .5) +\n    ggtitle(paste(\"Model 2: P(y <= \", k, \")\", sep=\"\"),\n            subtitle = \"1 dot = 100 observations\")\n  \n  print(p2)\n  }\n```\n\n::: {.cell-output-display}\n![](ordinal_files/figure-html/reliability-diagrams_2-1.svg){fig-align='left'}\n:::\n\n::: {.cell-output-display}\n![](ordinal_files/figure-html/reliability-diagrams_2-2.svg){fig-align='left'}\n:::\n\n::: {.cell-output-display}\n![](ordinal_files/figure-html/reliability-diagrams_2-3.svg){fig-align='left'}\n:::\n\n::: {.cell-output-display}\n![](ordinal_files/figure-html/reliability-diagrams_2-4.svg){fig-align='left'}\n:::\n\n\n:::\n\n\n:::\n\n\n\n\n\n",
    "supporting": [
      "ordinal_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}